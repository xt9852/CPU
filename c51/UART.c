#include <reg52.h>
#include "UART.h"

#ifndef NULL
#define NULL 0
#endif


UART_PROC  g_uart_proc  = NULL;
void      *g_uart_param = NULL;


// 发送1个字符
void UART_send_byte(unsigned char ch)
{
	SBUF = ch;
	while (!TI);  // 发送中断标志位，数据发送结束时，标志位会自动置1，需要通过程序将其置0
	TI = 0;
}

// 发送字符串
void UART_send_string(char *str)
{
	while (*str != '\0')
	{
		UART_send_byte(*str++);
	}
}

// 串口中断入口函数
void UART_interrupt_func() interrupt 4
{
	if (RI)								// 接收中断标志位，数据接收结束时，标志位会自动置1
	{
		RI = 0;							// 将接收中断标志位复位等待接收下一个字节
        g_uart_proc(SBUF, g_uart_param);
	}
}

// 初始化串口中断
void UART_init(unsigned long baud, UART_PROC proc, void *param)
{
    // 串口工作方式寄存器 SCON
    //
    // 位置	    D7	D6	D5	D4	D3	D2	D1	D0
    // 功能     SM0	SM1	SM2	REN	TB8	RB8	TI	RI
    //
    // RI       接收中断标志位，数据接收结束时，标志位会自动置1，需要通过程序将其置0
    // TI       发送中断标志位，数据发送结束时，标志位会自动置1，需要通过程序将其置0
    // RB8      存放发送数据的第9位
    // TB8      存放接收数据的第9位
    // REN      串行接收允许位，0允许串行接收，1禁止串行接收
    // SM2      多机控制位
    // SM1 SM0  串行工作方式
    //
    // SM0 SM1 方式	说明	                    波特率
    // 0   0    0   移位寄存器	                晶振频率/12
    // 0   1    1   10位异步收发器（8位数据）	可变
    // 1   0    2   11位异步收发器（9位数据）	晶振频率/32或晶振频率/64
    // 1   1    3   11位异步收发器（9位数据）	可变

    // -----------------------------------------------------------------------
    // 计数器工作方式寄存器 TMOD
    //
    // 位置	    D7   D6	  D5   D4   D3   D2	  D1   D0
    // 功能	    GATE C/T  M1   M0   GATE C/T  M1   M0
    //
    // 高四位为定时计数器T1的设置，低四位是定时计数器T0设置
    //
    // C/T      定时器和计数器选择位，0-定时器，1-计数器
    // M1	M0	工作方式
    //
    // 0	0   工作方式0：为13位定时/计数器
    // 0	1	工作方式1：为16位定时/计数器
    // 1	0	工作方式2：8位初值自动重装定时/计数器
    // 1	1	工作方式3：仅适用于T0，分成两个8位计数器，T1停止计数

    // 振荡周期：也称时钟周期（频率的倒数），单片机提供时钟信号的振荡源周期，频率一般有11.0592MHz，12MHz等
    // 状态周期：是振荡周期的2倍
    // 机器周期：是包含6个状态周期，机器周期=1/单片机时钟频率
    // 单片机时钟频率：是外部时钟的12分频，如果是12MHz的晶振，机器周期=1/单片机时钟频率=1/（12MHz/12）=12/12M=1us
    // 这里一个机器周期为1us，若定时时间为1ms，则需要1000个机器周期，计算出初值；如果机器周期为2us，则只需要500个机器周期。
    // 定时器初值计算：初值=（65536-机器周期数量）
    // 波特率计算：
    // 当串口工作在工作方式0和2是，波特率固定，方式0时fosc/12;方式2时fosc/32或fosc/64（根据SMOD判断）。
    // 当串口工作在方式1时，波特率=(2^SMOD/32)*(单片机时钟频率/(256-X)),X是初值
    
    // -----------------------------------------------------------------------
    // 电源管理寄存器PCON
    //
    // 位置	    D7   D6	  D5   D4   D3   D2	  D1   D0
    // 功能	    SMOD  -	  -	   -	GF1  GF0  PD   IDL
    // 
    // SOMD     波特率是否加倍选择位，0波特率不加倍，1波特率加倍
    // GF1 GF0  通用标志位。
    // PD       掉电方式位。当PD=1 时，进入掉电方式
    // IDL      待机方式位。当IDL=1 时，进入待机方式
    //
    // 波特率不加倍时：TH1 = TL1 = 晶振值/12/2/16/波特率
    // 当波特率加倍时：TH1 = TL1 = 晶振值/12/16/波特率

    // -----------------------------------------------------------------------
    // 中断允许寄存器 IE
    //
    // 位置	    D7   D6	  D5   D4   D3   D2	  D1   D0
    // 功能	    EA   -	  -	   ES   ET1  EX1  ET0  EX0
    //
    // EA       全避中断允许位
    // ET2      定时/计数器2中断允许位
    // ES       串口中断允许位
    // ET1      定时/计数器1中断允许位
    // EX1      外部中断1允许位
    // ET0      定时/计数器0中断允许位
    // EX0      外部中断0允许位

    TMOD |= 0x20;						// 设置计数器1的工作方式为2，8位初值自动重装定时/计数器
    PCON = 0x00;						// 波特率不加倍
    SCON = 0x50;						// 设置串口工作方式为1，10位异步收发器（8位数据）

    TH1  = 256 - (12000000/12/32)/baud; // 计数器的初值,板子使用12M晶振，初值=256-12000000/12/32/波特率
	TL1  = TH1;                         // 12M的晶振波特率只能是2400，9600会有7.8%的误差，会产生乱码，而2400误差是0.16%
	   
    EA   = 1;							// 开启总中断
    ES   = 1;							// 开启串口接收中断
	TR1  = 1;							// 开启计数器

    g_uart_proc = proc;
    g_uart_param = param;
}
